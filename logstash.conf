########### PRODUCTION LOGSTASH CONF ############
# Create the Elasticsearch indexes and load     #
# data from PostgreSQL database.                #
#################################################

input {
  jdbc { 
    jdbc_connection_string => "${JDBC_POSTGRESQL}"
    # The user we wish to execute our statement as
    jdbc_user => "${JDBC_USER}"
    jdbc_password => "${JDBC_PASSWORD}"
    # The path to our downloaded jdbc driver
    jdbc_driver_library => "/config-dir/postgresql-connector.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    # our query
    statement => "
      SELECT  
        doc.*,
        t_description.title as title,
        t_description.body as description,
        string_agg(s.code || ' - ' || s.subject, ', ' ORDER BY s.code) as subjects,
        string_agg(lib.id || ' - ' || lib.lib_name, '') as library,
        string_agg(caver.nickname, '; ') as authors,
        string_agg(r.name, ', ') as regions
      FROM t_document as doc
      LEFT JOIN j_document_subject jds ON jds.id_document = doc.id
      LEFT JOIN t_subject s ON s.code = jds.code_subject
      LEFT JOIN (
        SELECT g.id, n.name as lib_name
        FROM t_grotto g
        LEFT JOIN t_name n ON g.id = n.id_grotto
        WHERE n.is_main = true
      ) lib ON lib.id = doc.id_library
      LEFT JOIN (
        SELECT g.id, n.name as lib_name
        FROM t_grotto g
        LEFT JOIN t_name n ON g.id = n.id_grotto
        WHERE n.is_main = true
      ) editor ON editor.id = doc.id_editor
      LEFT JOIN j_document_caver_author jdca ON jdca.id_document = doc.id
      LEFT JOIN t_caver caver ON caver.id = jdca.id_caver
      LEFT JOIN t_description ON t_description.id_document = doc.id
      LEFT JOIN j_document_region jdcr ON jdcr.id_document = doc.id
      LEFT JOIN t_region r ON r.id = jdcr.id_region
      WHERE is_validated = true
      GROUP BY doc.id, t_description.id
    "
    type => "document"
  }
  jdbc { 
    jdbc_connection_string => "${JDBC_POSTGRESQL}"
    # The user we wish to execute our statement as
    jdbc_user => "${JDBC_USER}"
    jdbc_password => "${JDBC_PASSWORD}"
    # The path to our downloaded jdbc driver
    jdbc_driver_library => "/config-dir/postgresql-connector.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    # our query
    statement => "
      SELECT 
        e.*, 
        string_agg(DISTINCT n.name, ', ') AS names,
        string_agg(d.title || ' ' || d.body, ', ') AS descriptions,
        AVG(c.approach) AS approach,
        AVG(c.aestheticism) AS aestheticism,
        AVG(c.caving) AS caving,
        main_n.main_name AS name
      FROM t_entrance AS e
      LEFT JOIN t_name n ON n.id_entrance = e.id
      LEFT JOIN t_description d on d.id_entrance = e.id
      LEFT JOIN t_comment c on c.id_entrance = e.id
      LEFT JOIN (
        SELECT t_name.id_entrance AS id, t_name.name AS main_name
        FROM t_name
        WHERE t_name.is_main = true
      ) main_n ON main_n.id = e.id
      GROUP BY e.id, main_n.main_name
    "
    type => "entrance"
  }
  jdbc { 
    jdbc_connection_string => "${JDBC_POSTGRESQL}"
    # The user we wish to execute our statement as
    jdbc_user => "${JDBC_USER}"
    jdbc_password => "${JDBC_PASSWORD}"
    # The path to our downloaded jdbc driver
    jdbc_driver_library => "/config-dir/postgresql-connector.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    # our query
    statement => "
      SELECT
        m.*,
        string_agg(DISTINCT n.name, ', ') AS names,
        string_agg(d.title || ' ' || d.body, '## ') AS descriptions,
        main_n.main_name AS name
      FROM t_massif AS m
      LEFT JOIN t_name n ON n.id_massif = m.id
      LEFT JOIN t_description d ON d.id_massif = m.id
      LEFT JOIN (
        SELECT t_name.id_massif AS id, t_name.name AS main_name
        FROM t_name
        WHERE t_name.is_main = true
      ) main_n ON main_n.id = m.id
      GROUP BY m.id, main_n.main_name
    "
    type => "massif"
  }
  jdbc { 
    jdbc_connection_string => "${JDBC_POSTGRESQL}"
    # The user we wish to execute our statement as
    jdbc_user => "${JDBC_USER}"
    jdbc_password => "${JDBC_PASSWORD}"
    # The path to our downloaded jdbc driver
    jdbc_driver_library => "/config-dir/postgresql-connector.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    # our query
    statement => "
      SELECT
        g.*,
        string_agg(DISTINCT n.name, ', ') AS names,
        COUNT(jgc.id_caver) AS \"number of cavers\",
        main_n.main_name AS name
      FROM t_grotto AS g
      LEFT JOIN t_name n ON n.id_grotto = g.id
      LEFT JOIN j_grotto_caver jgc ON jgc.id_grotto = g.id
      LEFT JOIN (
        SELECT t_name.id_grotto AS id, t_name.name AS main_name
        FROM t_name
        WHERE t_name.is_main = true
      ) main_n ON main_n.id = g.id
      GROUP BY g.id, main_n.main_name
    "
    type => "grotto"
  }
}
output {
  # debugging purpose
  # stdout { codec => json_lines }
  if [type] == "entrance" {
    elasticsearch {
      hosts => "${ES_HOSTS}"
      index => "entrances-index"
      document_type => "data"
      action => "update"
      document_id => "%{id}"
      doc_as_upsert => true
    }
  }

  if [type] == "massif" {
    elasticsearch {
      hosts => "${ES_HOSTS}"
      index => "massifs-index"
      document_type => "data"
      action => "update"
      document_id => "%{id}"
      doc_as_upsert => true
    }
  }

  if [type] == "grotto" {
    elasticsearch {
      hosts => "${ES_HOSTS}"
      index => "grottos-index"
      document_type => "data"
      action => "update"
      document_id => "%{id}"
      doc_as_upsert => true
    }
  }

  if [type] == "document" {
    elasticsearch {
      hosts => "${ES_HOSTS}"
      index => "doc-index"
      document_type => "data"
      action => "update"
      document_id => "%{id}"
      doc_as_upsert => true
    }
  }
}